# Architecture Decisions Index (YAML Database)
#
# This YAML file serves as the central index/registry for all architecture decisions in the project.
# Each top-level key is a semantic token (e.g., ARCH-STDD_STRUCTURE).
#
# To append a new architecture decision:
# 1. Copy the template block at the bottom of this file (ARCH-IDENTIFIER)
# 2. Paste it at the end with a blank line before it
# 3. Replace ARCH-IDENTIFIER with your new token
# 4. Fill in all fields
# 5. Update the detail_file path to match your new .md file in architecture-decisions/ directory
#
# Field descriptions:
#   name: Short descriptive name of the decision
#   status: Active | Deprecated | Template | Superseded
#   cross_references: List of REQ-* tokens this decision fulfills
#   created: YYYY-MM-DD
#   last_updated: YYYY-MM-DD
#   rationale: Why this decision was made - use | for multi-line
#   alternatives_considered: What alternatives were evaluated and why rejected - use | for multi-line
#   implementation_approach: High-level approach, key components, integration points - use | for multi-line
#   traceability: Links to requirements, implementation, tests, code - use | for multi-line
#   related_decisions: Lists of depends_on, informs, see_also (YAML lists or [])
#   detail_file: Path to the detailed .md file in architecture-decisions/ directory
#   last_validated: YYYY-MM-DD
#   last_validator: agent/contributor name

---

ARCH-STDD_STRUCTURE:
  name: STDD Project Structure
  status: Active
  cross_references:
    - REQ-STDD_SETUP
  created: 2025-12-18
  last_updated: 2026-02-06
  rationale: |
    - Keeps documentation close to code but organized in a dedicated namespace
    - Ensures the AI agent can easily find all context in one place
    - Separates meta-documentation from project source code
    - Clear separation of concerns
    - Standard project layout
    - Testable components
  alternatives_considered: |
    - **Root-level files**: Rejected - clutters the root directory
    - **`.github` or `.docs` folder**: Rejected - `stdd` is more specific to the methodology
  implementation_approach: |
    - Create `stdd/` directory at project root
    - Populate with template files:
      - `requirements.yaml` (index) with `requirements/` directory for detail .md files
      - `architecture-decisions.yaml` (index) with `architecture-decisions/` directory for detail .md files
      - `implementation-decisions.yaml` (index) with `implementation-decisions/` directory for detail .md files
      - `semantic-tokens.md` (central token registry)
      - `tasks.md` (task tracking)
      - `processes.md` (process tracking)
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-STDD_SETUP
    **Implementation**: See `implementation-decisions.yaml` § IMPL-STDD_FILES
    **Tests**: `TestSTDDSetup_REQ_STDD_SETUP` ensures docs + registry exist
    **Code**: Bootstrap scripts with `// [IMPL-STDD_FILES] [ARCH-STDD_STRUCTURE] [REQ-STDD_SETUP]`
  related_decisions:
    depends_on:
      - REQ-STDD_SETUP
    informs:
      - IMPL-STDD_FILES
    see_also: []
  detail_file: architecture-decisions/ARCH-STDD_STRUCTURE.md
  last_validated: 2026-02-06
  last_validator: AI agent

ARCH-MODULE_VALIDATION:
  name: Module Validation Strategy
  status: Active
  cross_references:
    - REQ-MODULE_VALIDATION
  created: 2025-12-18
  last_updated: 2026-02-06
  rationale: |
    - Eliminates bugs related to code complexity by ensuring each module works correctly in isolation
    - Reduces integration complexity by validating modules independently before combining them
    - Catches bugs early in the development cycle, before integration issues compound
    - Ensures each module meets its defined contract before integration
    - Makes debugging easier by isolating issues to specific modules
    - Enables parallel development of modules when dependencies are properly mocked
  alternatives_considered: |
    - **Big Bang Integration**: Integrating all modules at once without independent validation
      - Rejected: Too complex, makes debugging difficult, bugs compound
    - **Minimal Validation**: Only basic unit tests before integration
      - Rejected: Insufficient to catch complexity-related bugs, doesn't validate contracts properly
    - **Post-Integration Validation Only**: Validating only after integration
      - Rejected: Doesn't catch module-level bugs early, increases debugging complexity
  implementation_approach: |
    ### Module Identification Requirements
    - Modules must be identified and documented before development begins
    - Each module must have clear boundaries and responsibilities
    - Module interfaces and contracts must be defined and documented
    - Module dependencies must be identified and documented
    - Module validation criteria must be specified (what "validated" means for each module)

    ### Validation Approach
    - **Unit Testing**: Each module must have comprehensive unit tests with mocked dependencies
    - **Integration Testing with Test Doubles**: Modules must be tested with mocks, stubs, or fakes for dependencies
    - **Contract Validation**: Input/output validation to ensure modules meet their defined contracts
    - **Edge Case Testing**: Modules must be tested with edge cases and boundary conditions
    - **Error Handling Validation**: Modules must be tested for proper error handling and error propagation

    ### Integration Requirements
    - Integration tasks must be separate from module development and validation tasks
    - Integration only occurs after module validation passes
    - Integration tests validate the combined behavior of validated modules
    - Module validation results must be documented before integration
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-MODULE_VALIDATION
    **Implementation**: See `implementation-decisions.yaml` § IMPL-MODULE_VALIDATION
    **Tests**: `testModuleName_IndependentValidation_REQ_MODULE_VALIDATION` - Module validation tests
    **Code**: Module implementation files with `[IMPL-MODULE_VALIDATION]` comments
  related_decisions:
    depends_on:
      - REQ-MODULE_VALIDATION
    informs:
      - IMPL-MODULE_VALIDATION
    see_also: []
  detail_file: architecture-decisions/ARCH-MODULE_VALIDATION.md
  last_validated: 2026-02-06
  last_validator: AI agent

ARCH-LANGUAGE_SELECTION:
  name: Language and Runtime Selection
  status: Template
  cross_references: []
  created: YYYY-MM-DD
  last_updated: YYYY-MM-DD
  rationale: |
    Why this language/runtime was chosen for the project
  alternatives_considered: |
    - **Language A**: Why it was rejected
    - **Language B**: Why it was rejected
  implementation_approach: |
    How the selected language/runtime will be used in the project
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-*
    **Implementation**: See `implementation-decisions.yaml` § IMPL-*
    **Tests**: testFeatureName_ARCH_LANGUAGE_SELECTION
    **Code**: // [ARCH-LANGUAGE_SELECTION] in source files
  related_decisions:
    depends_on: []
    informs: []
    see_also: []
  detail_file: architecture-decisions/ARCH-LANGUAGE_SELECTION.md
  last_validated: YYYY-MM-DD
  last_validator: agent/contributor

ARCH-EXAMPLE_DECISION:
  name: Core Architecture Example
  status: Template
  cross_references:
    - REQ-EXAMPLE_FEATURE
  created: YYYY-MM-DD
  last_updated: YYYY-MM-DD
  rationale: |
    Why this architectural decision was made
    What problems it solves
    What benefits it provides
  alternatives_considered: |
    - **Alternative 1**: Why it was rejected
    - **Alternative 2**: Why it was rejected
  implementation_approach: |
    - High-level approach
    - Key components
    - Integration points
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-EXAMPLE_FEATURE
    **Implementation**: See `implementation-decisions.yaml` § IMPL-EXAMPLE_IMPLEMENTATION
    **Tests**: testFeatureName_ARCH_EXAMPLE_DECISION
    **Code**: // [ARCH-EXAMPLE_DECISION] in source files
  related_decisions:
    depends_on:
      - REQ-EXAMPLE_FEATURE
    informs:
      - IMPL-EXAMPLE_IMPLEMENTATION
    see_also: []
  detail_file: architecture-decisions/ARCH-EXAMPLE_DECISION.md
  last_validated: YYYY-MM-DD
  last_validator: agent/contributor

ARCH-ERROR_HANDLING:
  name: Error Handling Strategy
  status: Template
  cross_references:
    - REQ-ERROR_HANDLING
  created: YYYY-MM-DD
  last_updated: YYYY-MM-DD
  rationale: |
    Why this error handling approach was chosen
  alternatives_considered: |
    - **Exceptions**: Why rejected or why chosen
    - **Error codes**: Why rejected or why chosen
    - **Result types**: Why rejected or why chosen
  implementation_approach: |
    How errors will be handled throughout the application
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-ERROR_HANDLING
    **Implementation**: See `implementation-decisions.yaml` § IMPL-ERROR_HANDLING
    **Tests**: testErrorHandling_ARCH_ERROR_HANDLING
    **Code**: // [ARCH-ERROR_HANDLING] in source files
  related_decisions:
    depends_on:
      - REQ-ERROR_HANDLING
    informs:
      - IMPL-ERROR_HANDLING
    see_also: []
  detail_file: architecture-decisions/ARCH-ERROR_HANDLING.md
  last_validated: YYYY-MM-DD
  last_validator: agent/contributor

ARCH-TESTING_STRATEGY:
  name: Testing Strategy
  status: Template
  cross_references: []
  created: YYYY-MM-DD
  last_updated: YYYY-MM-DD
  rationale: |
    Why this testing strategy was chosen
  alternatives_considered: |
    - **Test Approach 1**: Why rejected or why chosen
    - **Test Approach 2**: Why rejected or why chosen
  implementation_approach: |
    - Unit testing approach
    - Integration testing approach
    - End-to-end testing approach
    - Test coverage goals
  traceability: |
    **Requirements**: See `requirements.yaml` § REQ-*
    **Implementation**: See `implementation-decisions.yaml` § IMPL-TESTING
    **Tests**: All test files follow this strategy
    **Code**: // [ARCH-TESTING_STRATEGY] in test files
  related_decisions:
    depends_on: []
    informs:
      - IMPL-TESTING
    see_also: []
  detail_file: architecture-decisions/ARCH-TESTING_STRATEGY.md
  last_validated: YYYY-MM-DD
  last_validator: agent/contributor

# ---
# Template Record - Copy this block to create new architecture decisions
# ---
#
# ARCH-IDENTIFIER:
#   name: Architecture Decision Title
#   status: Active
#   cross_references:
#     - REQ-RELATED_REQUIREMENT
#   created: YYYY-MM-DD
#   last_updated: YYYY-MM-DD
#   rationale: |
#     - Why this decision was made
#     - What problems it solves
#     - What benefits it provides
#   alternatives_considered: |
#     - **Alternative 1**: Why it was rejected
#     - **Alternative 2**: Why it was rejected
#   implementation_approach: |
#     - High-level approach
#     - Key components
#     - Integration points
#   traceability: |
#     **Requirements**: See `requirements.yaml` § REQ-IDENTIFIER
#     **Implementation**: See `implementation-decisions.yaml` § IMPL-IDENTIFIER
#     **Tests**: testFeatureName_ARCH_IDENTIFIER
#     **Code**: // [ARCH-IDENTIFIER] in source files
#   related_decisions:
#     depends_on: []
#     informs: []
#     see_also: []
#   detail_file: architecture-decisions/ARCH-IDENTIFIER.md
#   last_validated: YYYY-MM-DD
#   last_validator: agent/contributor
